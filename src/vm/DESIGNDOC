            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Milan Misak <mm5510@imperial.ac.uk>
Jack Bracewell <jb2910@doc.ic.ac.uk>
Craig Ellis <ce710@doc.ic.ac.uk>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

//TODO: structs (i'll do it all at once when everything will definitely stay
the same - it was a faff last time)


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

We have a a hash table for each function called a sup_page_table (
supplementary page table), consisting of page structs, this contains a user
virtual address field.

We also have a static frame table which is also a hash table containing
frame structs. Each frame contains a user virtual address field.
Entries in the frame table are created and destroyed to represent the 
page structs in the frame table.

To locate the frame that a page is in, we simply iterate through the 
frame table to check which frame contains the same user address as a given
page struct.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We avoid this issue by only accessing user memory through its user
virtual address. Except when writing to swap (The kernel virtual address is not
written to, so the dirty bit will not be changed).


---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

There is a lock (eviction lock) around the frame_evict () function, this 
means only one frame can be evicted at a time.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We decided to use hash tables for the frame and the page tables, because they have
efficient constant lookup for kernel addresses respectively. Creating a pointer
in the page struct to a given frame struct was not a good idea because it would
require making the page struct larger than it needed to be (making it more likely
that malloc could fail), also because of the relatively small number of entries in
the frame table it was not to expensive to just iterate through the table.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

//TODO: structs


---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We select a frame by choosing a random index in the frame table, check if it
is evictable (not pinned), otherwise another random frame will keep being
selected until an evictable one is found.


>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

First of all, the user virtual address is uninstalled from the pagedir
to indicate that Q's page is no longer in a frame.

The page from Q will have been written to swap or be in the file system.
So the information for reading that data again from a file, or from swap
is recorded in the supplementary page table.


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

If the page fault is for an address is greater than the stack pointer, then
this means a stack address was being accessed when the page fault occured. But
the fault address may have been accessed before the stack pointer was updated.
The PUSHA instuction can push 32 bytes onto the stack,so  we know that if the 
fault address is greater than esp - 33 then the fault was on the stack.

We now check if the page is in the supplementary page table, in which case it is 
loaded. Otherwise, the stack is extended. Unless the esp - 32 value is less
than PHYS_BASE - 8MB, this means the stack has overflowed the limit we imposed, in
which case the process exits.


---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

//TODO: implement synchronisation


>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

There is a lock around frame_evict, which selects a frame to evict at
random and writes its contents to swap, freeing the frame. Crucially
the frame being evicted is removed from process Q's page directory.
This will cause a page fault if Q tries to access any of this memory, 
it will not be able to get access to the memory without evicting
a page, and will not be able to do so until process P has finished
evicting it (writing to swap) and it releases the lock.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

Pinning?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

//TODO dont know if this is right
If a virtual address is invalid then the page fault handler will kill
the process if it fills any of the criteria declaring it an invalid 
address.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

Our design falls on the minimal locking end of the continuum, we decided to
design it this way because of its ease of readability, and to minimise the 
chances of deadlock.


             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

//TODO: structs


---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

When a memory-mapped file is in the process of being mapped to a specific
memory location we find out what its size is. Then we can use this knowledge
for inserting sufficient number of entries into the supplemental page table.

Our page fault handling code has three different cases for loading data from
either swap or a memory-mapped file or lazily from a program executable file.

While evicting a page we check if the page is writable and has been changed
(by checking the dirty bit). If both of these conditions are true the page
is written to swap.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

We first check the list of all mappings for the current thread to see if
there is an overlap between address space regions. If there is none we then
check current thread's supplemental page table to see if there is a collision
between the required address space and any existing data or code at all the
affected page-aligned address locations.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

The eviction code is shared, ie. not divided for different cases. Eviction
code is relatively straightforward and it does not matter too much where
the affected page comes from. We only need to check if it needs to be swapped.

Code for loading a page from an executable and a memory mapped file is fairly
similar. However, we chose to differ the implementation for each one of these
two cases. The overall structure of these cases is almost the same but
arguments passed to other methods in the implementation are completely
different and calculated in distinct ways. We feel that it is more readable
to keep two separate implementations than trying to merge them together and
clutter the result with many if statements and control flow code.


               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining tasks?

>> Any other comments?
